//==============================================================================
// Elastic Buffer Testbench
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: FIFO_BACKPRESSURE
//
// Test Coverage:
//   - Basic write/read operations
//   - Credit flow control verification
//   - Backpressure handling
//   - Full/empty conditions
//   - Throughput measurement
//   - Latency measurement
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

`timescale 1ns/1ps

module elastic_buffer_tb;

    //--------------------------------------------------------------------------
    // Parameters
    //--------------------------------------------------------------------------
    localparam int DEPTH = {{ params.BUFFER_DEPTH }};
    localparam int WIDTH = {{ params.DATA_WIDTH }};
    localparam int CREDIT_THRESHOLD = {{ params.CREDIT_THRESHOLD }};
    localparam bit REGISTER_OUTPUT = {{ '1' if params.REGISTER_OUTPUT else '0' }};

    // Test parameters
    localparam int NUM_TEST_VECTORS = {{ metadata.min_test_vectors }};
    localparam int CLK_PERIOD_NS = 10;  // 100MHz
    localparam int TEST_TIMEOUT_CYCLES = NUM_TEST_VECTORS * 10;

    //--------------------------------------------------------------------------
    // Signals
    //--------------------------------------------------------------------------
    logic              clk;
    logic              rst_n;

    // Upstream interface
    logic [WIDTH-1:0]  up_data;
    logic              up_valid;
    logic              up_credit;

    // Downstream interface
    logic [WIDTH-1:0]  dn_data;
    logic              dn_valid;
    logic              dn_ready;

    // Status
    logic [$clog2(DEPTH):0] fill_level;
    logic              nearly_full;
    logic              nearly_empty;

    //--------------------------------------------------------------------------
    // DUT Instantiation
    //--------------------------------------------------------------------------
    elastic_buffer #(
        .DEPTH(DEPTH),
        .WIDTH(WIDTH),
        .CREDIT_THRESHOLD(CREDIT_THRESHOLD),
        .REGISTER_OUTPUT(REGISTER_OUTPUT)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .up_data(up_data),
        .up_valid(up_valid),
        .up_credit(up_credit),
        .dn_data(dn_data),
        .dn_valid(dn_valid),
        .dn_ready(dn_ready),
        .fill_level(fill_level),
        .nearly_full(nearly_full),
        .nearly_empty(nearly_empty)
    );

    //--------------------------------------------------------------------------
    // Clock Generation
    //--------------------------------------------------------------------------
    initial begin
        clk = 0;
        forever #(CLK_PERIOD_NS/2) clk = ~clk;
    end

    //--------------------------------------------------------------------------
    // Test Data Structures
    //--------------------------------------------------------------------------
    typedef struct {
        logic [WIDTH-1:0] data;
        int               send_time;
        int               recv_time;
    } transaction_t;

    transaction_t sent_queue[$];
    transaction_t recv_queue[$];

    // Statistics
    int total_sent;
    int total_received;
    int total_backpressure_cycles;
    int min_latency;
    int max_latency;
    longint sum_latency;

    //--------------------------------------------------------------------------
    // Producer Task
    //--------------------------------------------------------------------------
    task automatic producer(int num_transactions, int backpressure_prob = 0);
        transaction_t txn;
        int cycle_count = 0;

        for (int i = 0; i < num_transactions; i++) begin
            // Wait for credit
            while (!up_credit) begin
                @(posedge clk);
                cycle_count++;
                total_backpressure_cycles++;
                if (cycle_count > TEST_TIMEOUT_CYCLES) begin
                    $error("Producer timeout waiting for credit");
                    return;
                end
            end

            // Send data
            txn.data = $urandom();
            txn.send_time = $time;
            txn.recv_time = 0;

            up_data <= txn.data;
            up_valid <= 1'b1;
            sent_queue.push_back(txn);
            total_sent++;

            @(posedge clk);

            // Random gaps (simulate bursty traffic)
            if ($urandom_range(100) < backpressure_prob) begin
                up_valid <= 1'b0;
                repeat($urandom_range(1, 5)) @(posedge clk);
            end
        end

        up_valid <= 1'b0;
    endtask

    //--------------------------------------------------------------------------
    // Consumer Task
    //--------------------------------------------------------------------------
    task automatic consumer(int num_transactions, int backpressure_prob = 0);
        transaction_t expected;
        int cycle_count = 0;
        int recv_count = 0;
        int latency;

        while (recv_count < num_transactions) begin
            // Random backpressure
            if ($urandom_range(100) < backpressure_prob) begin
                dn_ready <= 1'b0;
                repeat($urandom_range(1, 3)) @(posedge clk);
            end

            dn_ready <= 1'b1;
            @(posedge clk);

            if (dn_valid && dn_ready) begin
                if (sent_queue.size() == 0) begin
                    $error("Received data but send queue empty!");
                    return;
                end

                expected = sent_queue.pop_front();

                // Verify data
                if (dn_data !== expected.data) begin
                    $error("Data mismatch! Expected: %h, Got: %h",
                           expected.data, dn_data);
                end

                // Calculate latency
                latency = ($time - expected.send_time) / CLK_PERIOD_NS;

                if (recv_count == 0 || latency < min_latency) min_latency = latency;
                if (latency > max_latency) max_latency = latency;
                sum_latency += latency;

                total_received++;
                recv_count++;
            end

            cycle_count++;
            if (cycle_count > TEST_TIMEOUT_CYCLES) begin
                $error("Consumer timeout");
                return;
            end
        end

        dn_ready <= 1'b0;
    endtask

    //--------------------------------------------------------------------------
    // Test Scenarios
    //--------------------------------------------------------------------------

    // Test 1: Basic functionality
    task test_basic();
        $display("\n=== Test 1: Basic Functionality ===");

        fork
            producer(100, 0);
            consumer(100, 0);
        join

        assert(total_sent == total_received)
            else $error("Sent/received mismatch: %d vs %d", total_sent, total_received);

        $display("  Sent: %d, Received: %d", total_sent, total_received);
        $display("  Latency - Min: %d, Max: %d, Avg: %0.1f cycles",
                 min_latency, max_latency, real'(sum_latency)/total_received);
    endtask

    // Test 2: Full throughput (no backpressure)
    task test_full_throughput();
        $display("\n=== Test 2: Full Throughput ===");

        reset_stats();

        fork
            producer(NUM_TEST_VECTORS, 0);
            consumer(NUM_TEST_VECTORS, 0);
        join

        $display("  Throughput: %0.2f%% (backpressure cycles: %d)",
                 100.0 * total_received / (total_received + total_backpressure_cycles),
                 total_backpressure_cycles);
    endtask

    // Test 3: Consumer backpressure
    task test_consumer_backpressure();
        $display("\n=== Test 3: Consumer Backpressure ===");

        reset_stats();

        fork
            producer(500, 0);
            consumer(500, 50);  // 50% consumer stall probability
        join

        $display("  Sent: %d, Received: %d", total_sent, total_received);
        $display("  Credit-based flow control prevented overflow: %s",
                 (total_sent == total_received) ? "PASS" : "FAIL");
    endtask

    // Test 4: Bursty traffic
    task test_bursty_traffic();
        $display("\n=== Test 4: Bursty Traffic ===");

        reset_stats();

        fork
            producer(500, 30);  // 30% producer gaps
            consumer(500, 30);  // 30% consumer stalls
        join

        $display("  Sent: %d, Received: %d", total_sent, total_received);
        $display("  Latency - Min: %d, Max: %d, Avg: %0.1f cycles",
                 min_latency, max_latency, real'(sum_latency)/total_received);
    endtask

    // Test 5: Fill and drain
    task test_fill_drain();
        $display("\n=== Test 5: Fill and Drain ===");

        reset_stats();
        dn_ready <= 1'b0;

        // Fill buffer
        for (int i = 0; i < DEPTH - CREDIT_THRESHOLD; i++) begin
            while (!up_credit) @(posedge clk);
            up_data <= $urandom();
            up_valid <= 1'b1;
            @(posedge clk);
        end
        up_valid <= 1'b0;

        // Check nearly_full
        @(posedge clk);
        $display("  After fill: fill_level=%d, nearly_full=%b",
                 fill_level, nearly_full);

        // Drain buffer
        dn_ready <= 1'b1;
        repeat(DEPTH * 2) @(posedge clk);

        // Check nearly_empty
        $display("  After drain: fill_level=%d, nearly_empty=%b",
                 fill_level, nearly_empty);

        assert(fill_level == 0)
            else $error("Buffer not empty after drain!");
    endtask

    //--------------------------------------------------------------------------
    // Helper Tasks
    //--------------------------------------------------------------------------
    task reset_stats();
        total_sent = 0;
        total_received = 0;
        total_backpressure_cycles = 0;
        min_latency = 0;
        max_latency = 0;
        sum_latency = 0;
        sent_queue.delete();
        recv_queue.delete();
    endtask

    task reset_dut();
        rst_n <= 1'b0;
        up_data <= '0;
        up_valid <= 1'b0;
        dn_ready <= 1'b0;
        repeat(10) @(posedge clk);
        rst_n <= 1'b1;
        repeat(5) @(posedge clk);
    endtask

    //--------------------------------------------------------------------------
    // Main Test
    //--------------------------------------------------------------------------
    initial begin
        $display("\n");
        $display("==============================================================");
        $display("  Elastic Buffer Testbench");
        $display("  DEPTH=%0d, WIDTH=%0d, CREDIT_THRESHOLD=%0d",
                 DEPTH, WIDTH, CREDIT_THRESHOLD);
        $display("  REGISTER_OUTPUT=%0d", REGISTER_OUTPUT);
        $display("==============================================================");

        reset_stats();
        reset_dut();

        test_basic();
        reset_dut();
        reset_stats();

        test_full_throughput();
        reset_dut();
        reset_stats();

        test_consumer_backpressure();
        reset_dut();
        reset_stats();

        test_bursty_traffic();
        reset_dut();
        reset_stats();

        test_fill_drain();

        $display("\n");
        $display("==============================================================");
        $display("  All tests completed");
        $display("==============================================================");
        $display("\n");

        $finish;
    end

    //--------------------------------------------------------------------------
    // Timeout watchdog
    //--------------------------------------------------------------------------
    initial begin
        #(CLK_PERIOD_NS * TEST_TIMEOUT_CYCLES * 10);
        $error("Global timeout!");
        $finish;
    end

endmodule
