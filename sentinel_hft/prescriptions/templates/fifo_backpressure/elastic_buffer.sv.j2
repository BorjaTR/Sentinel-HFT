//==============================================================================
// Elastic Buffer with Credit-Based Flow Control
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: FIFO_BACKPRESSURE
//
// Parameters:
//   BUFFER_DEPTH = {{ params.BUFFER_DEPTH }}
//   DATA_WIDTH = {{ params.DATA_WIDTH }}
//   CREDIT_THRESHOLD = {{ params.CREDIT_THRESHOLD }}
//   REGISTER_OUTPUT = {{ params.REGISTER_OUTPUT }}
//
// Expected Impact:
//   Latency reduction: ~{{ metadata.expected_latency_reduction_pct }}%
//   Throughput improvement: ~{{ metadata.expected_throughput_improvement_pct }}%
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

module elastic_buffer #(
    parameter int DEPTH = {{ params.BUFFER_DEPTH }},
    parameter int WIDTH = {{ params.DATA_WIDTH }},
    parameter int CREDIT_THRESHOLD = {{ params.CREDIT_THRESHOLD }},
    parameter bit REGISTER_OUTPUT = {{ '1' if params.REGISTER_OUTPUT else '0' }}
) (
    input  logic              clk,
    input  logic              rst_n,

    // Upstream interface (producer)
    input  logic [WIDTH-1:0]  up_data,
    input  logic              up_valid,
    output logic              up_credit,  // High when buffer has space

    // Downstream interface (consumer)
    output logic [WIDTH-1:0]  dn_data,
    output logic              dn_valid,
    input  logic              dn_ready,

    // Status (for monitoring)
    output logic [$clog2(DEPTH):0] fill_level,
    output logic              nearly_full,
    output logic              nearly_empty
);

    //--------------------------------------------------------------------------
    // Local Parameters
    //--------------------------------------------------------------------------
    localparam int ADDR_WIDTH = $clog2(DEPTH);
    localparam int ALMOST_FULL_THRESHOLD = DEPTH - CREDIT_THRESHOLD;
    localparam int ALMOST_EMPTY_THRESHOLD = CREDIT_THRESHOLD;

    //--------------------------------------------------------------------------
    // Internal Signals
    //--------------------------------------------------------------------------
    logic [ADDR_WIDTH-1:0] wr_ptr;
    logic [ADDR_WIDTH-1:0] rd_ptr;
    logic [ADDR_WIDTH:0]   count;  // Extra bit for full/empty detection

    logic                  wr_en;
    logic                  rd_en;
    logic [WIDTH-1:0]      rd_data;

    // Buffer storage
    logic [WIDTH-1:0]      buffer [DEPTH];

    //--------------------------------------------------------------------------
    // Write Logic
    //--------------------------------------------------------------------------
    assign wr_en = up_valid && up_credit;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            wr_ptr <= '0;
        end else if (wr_en) begin
            wr_ptr <= wr_ptr + 1'b1;
        end
    end

    always_ff @(posedge clk) begin
        if (wr_en) begin
            buffer[wr_ptr] <= up_data;
        end
    end

    //--------------------------------------------------------------------------
    // Read Logic
    //--------------------------------------------------------------------------
    generate
        if (REGISTER_OUTPUT) begin : gen_registered_output
            // Registered output for better timing
            logic              rd_valid_reg;
            logic [WIDTH-1:0]  rd_data_reg;

            assign rd_en = (count > 0) && (!rd_valid_reg || dn_ready);

            always_ff @(posedge clk or negedge rst_n) begin
                if (!rst_n) begin
                    rd_ptr <= '0;
                    rd_valid_reg <= 1'b0;
                end else begin
                    if (rd_en) begin
                        rd_ptr <= rd_ptr + 1'b1;
                        rd_valid_reg <= 1'b1;
                        rd_data_reg <= buffer[rd_ptr];
                    end else if (dn_ready) begin
                        rd_valid_reg <= 1'b0;
                    end
                end
            end

            // Output skid buffer for full throughput
            logic              skid_valid;
            logic [WIDTH-1:0]  skid_data;

            always_ff @(posedge clk or negedge rst_n) begin
                if (!rst_n) begin
                    skid_valid <= 1'b0;
                end else begin
                    if (rd_valid_reg && !dn_ready && !skid_valid) begin
                        skid_valid <= 1'b1;
                        skid_data <= rd_data_reg;
                    end else if (dn_ready) begin
                        skid_valid <= 1'b0;
                    end
                end
            end

            assign dn_valid = skid_valid || rd_valid_reg;
            assign dn_data = skid_valid ? skid_data : rd_data_reg;

        end else begin : gen_combinational_output
            // Combinational output (lower latency, tighter timing)
            assign rd_en = (count > 0) && dn_ready;
            assign rd_data = buffer[rd_ptr];

            always_ff @(posedge clk or negedge rst_n) begin
                if (!rst_n) begin
                    rd_ptr <= '0;
                end else if (rd_en) begin
                    rd_ptr <= rd_ptr + 1'b1;
                end
            end

            assign dn_valid = (count > 0);
            assign dn_data = rd_data;
        end
    endgenerate

    //--------------------------------------------------------------------------
    // Count and Credit Logic
    //--------------------------------------------------------------------------
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            count <= '0;
        end else begin
            case ({wr_en, rd_en})
                2'b10:   count <= count + 1'b1;
                2'b01:   count <= count - 1'b1;
                default: count <= count;
            endcase
        end
    end

    // Credit-based flow control
    // Upstream gets credit when buffer has space
    assign up_credit = (count < DEPTH - CREDIT_THRESHOLD);

    //--------------------------------------------------------------------------
    // Status Outputs
    //--------------------------------------------------------------------------
    assign fill_level = count;
    assign nearly_full = (count >= ALMOST_FULL_THRESHOLD);
    assign nearly_empty = (count <= ALMOST_EMPTY_THRESHOLD);

    //--------------------------------------------------------------------------
    // Assertions (for simulation)
    //--------------------------------------------------------------------------
`ifdef SIMULATION
    // synthesis translate_off

    // Check for overflow
    assert property (@(posedge clk) disable iff (!rst_n)
        wr_en |-> (count < DEPTH)
    ) else $error("Buffer overflow!");

    // Check for underflow
    assert property (@(posedge clk) disable iff (!rst_n)
        rd_en |-> (count > 0)
    ) else $error("Buffer underflow!");

    // Credit should prevent overflow
    assert property (@(posedge clk) disable iff (!rst_n)
        !up_credit |-> (count >= DEPTH - CREDIT_THRESHOLD)
    ) else $error("Credit logic error!");

    // synthesis translate_on
`endif

endmodule
