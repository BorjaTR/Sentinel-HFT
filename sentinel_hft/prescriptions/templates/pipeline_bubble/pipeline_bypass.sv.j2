//==============================================================================
// Pipeline Bypass Network with Hazard Detection
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: PIPELINE_BUBBLE
//
// Parameters:
//   NUM_STAGES = {{ params.NUM_STAGES }}
//   DATA_WIDTH = {{ params.DATA_WIDTH }}
//   NUM_OPERANDS = {{ params.NUM_OPERANDS }}
//   REG_ADDR_WIDTH = {{ params.REG_ADDR_WIDTH }}
//   ENABLE_FULL_BYPASS = {{ params.ENABLE_FULL_BYPASS }}
//   STALL_ON_LOAD = {{ params.STALL_ON_LOAD }}
//
// Expected Impact:
//   Latency reduction: ~{{ metadata.expected_latency_reduction_pct }}%
//   Throughput improvement: ~{{ metadata.expected_throughput_improvement_pct }}%
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

module pipeline_bypass #(
    parameter int NUM_STAGES = {{ params.NUM_STAGES }},
    parameter int DATA_WIDTH = {{ params.DATA_WIDTH }},
    parameter int NUM_OPERANDS = {{ params.NUM_OPERANDS }},
    parameter int REG_ADDR_WIDTH = {{ params.REG_ADDR_WIDTH }},
    parameter bit ENABLE_FULL_BYPASS = {{ '1' if params.ENABLE_FULL_BYPASS else '0' }},
    parameter bit STALL_ON_LOAD = {{ '1' if params.STALL_ON_LOAD else '0' }}
) (
    input  logic                          clk,
    input  logic                          rst_n,

    // Source operand addresses (from decode)
    input  logic [NUM_OPERANDS-1:0][REG_ADDR_WIDTH-1:0] src_addr,
    input  logic [NUM_OPERANDS-1:0]       src_valid,

    // Destination info from each stage
    input  logic [NUM_STAGES-1:0][REG_ADDR_WIDTH-1:0] stage_dst_addr,
    input  logic [NUM_STAGES-1:0]         stage_dst_valid,
    input  logic [NUM_STAGES-1:0]         stage_is_load,  // Load instructions
    input  logic [NUM_STAGES-1:0][DATA_WIDTH-1:0] stage_result,

    // Register file read data (fallback)
    input  logic [NUM_OPERANDS-1:0][DATA_WIDTH-1:0] rf_read_data,

    // Forwarded operands
    output logic [NUM_OPERANDS-1:0][DATA_WIDTH-1:0] fwd_data,
    output logic [NUM_OPERANDS-1:0]       fwd_valid,

    // Hazard signals
    output logic                          stall_needed,
    output logic                          flush_needed
);

    //--------------------------------------------------------------------------
    // Local Types
    //--------------------------------------------------------------------------
    typedef enum logic [2:0] {
        FWD_NONE    = 3'b000,
        FWD_STAGE_0 = 3'b001,  // Execute
        FWD_STAGE_1 = 3'b010,  // Memory
        FWD_STAGE_2 = 3'b011,  // Writeback
        FWD_STAGE_3 = 3'b100,  // Extra stage if present
        FWD_RF      = 3'b111   // Register file
    } fwd_sel_t;

    //--------------------------------------------------------------------------
    // Forwarding Logic
    //--------------------------------------------------------------------------
    fwd_sel_t [NUM_OPERANDS-1:0] fwd_select;
    logic [NUM_OPERANDS-1:0] load_use_hazard;

    always_comb begin
        stall_needed = 1'b0;
        flush_needed = 1'b0;

        for (int op = 0; op < NUM_OPERANDS; op++) begin
            fwd_select[op] = FWD_RF;
            fwd_valid[op] = src_valid[op];
            load_use_hazard[op] = 1'b0;

            if (src_valid[op]) begin
                // Check each stage for matching destination (priority: earliest stage)
                for (int s = 0; s < NUM_STAGES; s++) begin
                    if (ENABLE_FULL_BYPASS || s < 2) begin  // Full bypass or just EX/MEM
                        if (stage_dst_valid[s] && (stage_dst_addr[s] == src_addr[op])) begin
                            // Check for load-use hazard (load in EX stage)
                            if (STALL_ON_LOAD && s == 0 && stage_is_load[s]) begin
                                load_use_hazard[op] = 1'b1;
                                stall_needed = 1'b1;
                                fwd_select[op] = FWD_RF;  // Will get correct value after stall
                            end else begin
                                case (s)
                                    0: fwd_select[op] = FWD_STAGE_0;
                                    1: fwd_select[op] = FWD_STAGE_1;
                                    2: fwd_select[op] = FWD_STAGE_2;
                                    3: fwd_select[op] = FWD_STAGE_3;
                                    default: fwd_select[op] = FWD_RF;
                                endcase
                            end
                            break;  // First match wins (closest producer)
                        end
                    end
                end
            end
        end
    end

    //--------------------------------------------------------------------------
    // Forwarding Muxes
    //--------------------------------------------------------------------------
    always_comb begin
        for (int op = 0; op < NUM_OPERANDS; op++) begin
            case (fwd_select[op])
                FWD_STAGE_0: fwd_data[op] = stage_result[0];
                FWD_STAGE_1: fwd_data[op] = stage_result[1];
                FWD_STAGE_2: fwd_data[op] = stage_result[2];
                FWD_STAGE_3: fwd_data[op] = (NUM_STAGES > 3) ? stage_result[3] : rf_read_data[op];
                default:     fwd_data[op] = rf_read_data[op];
            endcase
        end
    end

    //--------------------------------------------------------------------------
    // Hazard Statistics (for debugging/monitoring)
    //--------------------------------------------------------------------------
`ifdef SIMULATION
    // synthesis translate_off

    int fwd_count[NUM_STAGES];
    int stall_count;
    int total_ops;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int s = 0; s < NUM_STAGES; s++) fwd_count[s] <= 0;
            stall_count <= 0;
            total_ops <= 0;
        end else begin
            for (int op = 0; op < NUM_OPERANDS; op++) begin
                if (src_valid[op]) begin
                    total_ops <= total_ops + 1;
                    case (fwd_select[op])
                        FWD_STAGE_0: fwd_count[0] <= fwd_count[0] + 1;
                        FWD_STAGE_1: fwd_count[1] <= fwd_count[1] + 1;
                        FWD_STAGE_2: fwd_count[2] <= fwd_count[2] + 1;
                        FWD_STAGE_3: if (NUM_STAGES > 3) fwd_count[3] <= fwd_count[3] + 1;
                        default: ;
                    endcase
                end
            end
            if (stall_needed) stall_count <= stall_count + 1;
        end
    end

    final begin
        $display("Pipeline Bypass Statistics:");
        $display("  Total operand lookups: %0d", total_ops);
        for (int s = 0; s < NUM_STAGES; s++) begin
            $display("  Forwards from stage %0d: %0d", s, fwd_count[s]);
        end
        $display("  Load-use stalls: %0d", stall_count);
        if (total_ops > 0) begin
            int total_fwd = 0;
            for (int s = 0; s < NUM_STAGES; s++) total_fwd += fwd_count[s];
            $display("  Bypass utilization: %0.1f%%", 100.0 * total_fwd / total_ops);
        end
    end

    // synthesis translate_on
`endif

    //--------------------------------------------------------------------------
    // Assertions
    //--------------------------------------------------------------------------
`ifdef SIMULATION
    // synthesis translate_off

    // Forwarded data should be valid when selected
    generate
        for (genvar op = 0; op < NUM_OPERANDS; op++) begin : gen_assert_op
            assert property (@(posedge clk) disable iff (!rst_n)
                (fwd_select[op] == FWD_STAGE_0) |-> stage_dst_valid[0]
            ) else $error("Forward from stage 0 but no valid destination!");
        end
    endgenerate

    // synthesis translate_on
`endif

endmodule
