# Integration Guide: Pipeline Bypass Network

> **Generated by Sentinel-HFT FixPack Generator**
> Pattern: PIPELINE_BUBBLE
> Generated: {{ metadata.generation_timestamp }}

## Overview

This fix addresses **pipeline bubble** issues detected in your latency trace. The bypass network eliminates stalls from RAW hazards by forwarding results directly between stages.

### Problem Statement

{{ metadata.problem_statement }}

### Solution Approach

{{ metadata.solution_approach }}

## Parameters Used

| Parameter | Value | Description |
|-----------|-------|-------------|
| NUM_STAGES | {{ params.NUM_STAGES }} | Pipeline depth |
| DATA_WIDTH | {{ params.DATA_WIDTH }} | Data path width |
| NUM_OPERANDS | {{ params.NUM_OPERANDS }} | Source operands per op |
| REG_ADDR_WIDTH | {{ params.REG_ADDR_WIDTH }} | Register address bits |
| ENABLE_FULL_BYPASS | {{ params.ENABLE_FULL_BYPASS }} | Bypass from all stages |
| STALL_ON_LOAD | {{ params.STALL_ON_LOAD }} | Handle load-use hazards |

## Expected Impact

- **Latency Reduction**: ~{{ metadata.expected_latency_reduction_pct }}%
- **Throughput Improvement**: ~{{ metadata.expected_throughput_improvement_pct }}%

## Integration Steps

### Step 1: Instantiate Bypass Network

```systemverilog
pipeline_bypass #(
    .NUM_STAGES({{ params.NUM_STAGES }}),
    .DATA_WIDTH({{ params.DATA_WIDTH }}),
    .NUM_OPERANDS({{ params.NUM_OPERANDS }}),
    .REG_ADDR_WIDTH({{ params.REG_ADDR_WIDTH }}),
    .ENABLE_FULL_BYPASS({{ '1' if params.ENABLE_FULL_BYPASS else '0' }}),
    .STALL_ON_LOAD({{ '1' if params.STALL_ON_LOAD else '0' }})
) u_bypass (
    .clk(clk),
    .rst_n(rst_n),

    // From decode stage
    .src_addr(decode_src_regs),
    .src_valid(decode_src_valid),

    // From each pipeline stage
    .stage_dst_addr({wb_dst, mem_dst, ex_dst}),
    .stage_dst_valid({wb_dst_valid, mem_dst_valid, ex_dst_valid}),
    .stage_is_load({1'b0, mem_is_load, ex_is_load}),
    .stage_result({wb_result, mem_result, ex_result}),

    // From register file
    .rf_read_data(rf_read_data),

    // To execute stage
    .fwd_data(ex_operands),
    .fwd_valid(ex_operands_valid),

    // Control signals
    .stall_needed(pipeline_stall),
    .flush_needed(pipeline_flush)
);
```

### Step 2: Connect Stall Logic

```systemverilog
// Stall decode and fetch when bypass network needs it
assign decode_stall = pipeline_stall;
assign fetch_stall = pipeline_stall;

// Insert bubble in execute
always_ff @(posedge clk) begin
    if (pipeline_stall) begin
        ex_valid <= 1'b0;  // Bubble
    end else begin
        ex_valid <= decode_valid;
    end
end
```

### Step 3: Use Forwarded Data

```systemverilog
// In execute stage, use forwarded operands instead of RF data
assign alu_op_a = fwd_data[0];
assign alu_op_b = fwd_data[1];
```

## Verification Checklist

- [ ] RAW hazards resolved without stalls (except load-use)
- [ ] Load-use hazard causes exactly 1 stall cycle
- [ ] Bypass priority correct (EX > MEM > WB)
- [ ] No data corruption in multi-operand scenarios
- [ ] Performance matches expected improvement

---

**CANDIDATE FIX - Review Required Before Use**
