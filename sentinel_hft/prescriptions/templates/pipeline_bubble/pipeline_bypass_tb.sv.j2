//==============================================================================
// Pipeline Bypass Network Testbench
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: PIPELINE_BUBBLE
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

`timescale 1ns/1ps

module pipeline_bypass_tb;

    //--------------------------------------------------------------------------
    // Parameters
    //--------------------------------------------------------------------------
    localparam int NUM_STAGES = {{ params.NUM_STAGES }};
    localparam int DATA_WIDTH = {{ params.DATA_WIDTH }};
    localparam int NUM_OPERANDS = {{ params.NUM_OPERANDS }};
    localparam int REG_ADDR_WIDTH = {{ params.REG_ADDR_WIDTH }};
    localparam bit ENABLE_FULL_BYPASS = {{ '1' if params.ENABLE_FULL_BYPASS else '0' }};
    localparam bit STALL_ON_LOAD = {{ '1' if params.STALL_ON_LOAD else '0' }};

    localparam int CLK_PERIOD_NS = 10;
    localparam int NUM_REGS = 1 << REG_ADDR_WIDTH;

    //--------------------------------------------------------------------------
    // Signals
    //--------------------------------------------------------------------------
    logic                          clk;
    logic                          rst_n;

    logic [NUM_OPERANDS-1:0][REG_ADDR_WIDTH-1:0] src_addr;
    logic [NUM_OPERANDS-1:0]       src_valid;

    logic [NUM_STAGES-1:0][REG_ADDR_WIDTH-1:0] stage_dst_addr;
    logic [NUM_STAGES-1:0]         stage_dst_valid;
    logic [NUM_STAGES-1:0]         stage_is_load;
    logic [NUM_STAGES-1:0][DATA_WIDTH-1:0] stage_result;

    logic [NUM_OPERANDS-1:0][DATA_WIDTH-1:0] rf_read_data;

    logic [NUM_OPERANDS-1:0][DATA_WIDTH-1:0] fwd_data;
    logic [NUM_OPERANDS-1:0]       fwd_valid;

    logic                          stall_needed;
    logic                          flush_needed;

    //--------------------------------------------------------------------------
    // DUT
    //--------------------------------------------------------------------------
    pipeline_bypass #(
        .NUM_STAGES(NUM_STAGES),
        .DATA_WIDTH(DATA_WIDTH),
        .NUM_OPERANDS(NUM_OPERANDS),
        .REG_ADDR_WIDTH(REG_ADDR_WIDTH),
        .ENABLE_FULL_BYPASS(ENABLE_FULL_BYPASS),
        .STALL_ON_LOAD(STALL_ON_LOAD)
    ) dut (.*);

    //--------------------------------------------------------------------------
    // Clock
    //--------------------------------------------------------------------------
    initial begin
        clk = 0;
        forever #(CLK_PERIOD_NS/2) clk = ~clk;
    end

    //--------------------------------------------------------------------------
    // Reference Model
    //--------------------------------------------------------------------------
    logic [DATA_WIDTH-1:0] reg_file [NUM_REGS];
    int bypass_count;
    int stall_count;
    int rf_read_count;

    //--------------------------------------------------------------------------
    // Test Tasks
    //--------------------------------------------------------------------------
    task reset_dut();
        rst_n <= 1'b0;
        src_addr <= '0;
        src_valid <= '0;
        stage_dst_addr <= '0;
        stage_dst_valid <= '0;
        stage_is_load <= '0;
        stage_result <= '0;
        rf_read_data <= '0;
        bypass_count = 0;
        stall_count = 0;
        rf_read_count = 0;

        // Initialize register file
        for (int i = 0; i < NUM_REGS; i++) begin
            reg_file[i] = i * 100;
            rf_read_data[0] = reg_file[i];
        end

        repeat(10) @(posedge clk);
        rst_n <= 1'b1;
        repeat(5) @(posedge clk);
    endtask

    // Test 1: No hazards (read from RF)
    task test_no_hazard();
        $display("\n=== Test 1: No Hazards ===");

        src_addr[0] <= 5;
        src_addr[1] <= 10;
        src_valid <= '1;
        rf_read_data[0] <= reg_file[5];
        rf_read_data[1] <= reg_file[10];

        // No destinations valid
        stage_dst_valid <= '0;

        @(posedge clk);
        #1;

        assert(!stall_needed) else $error("Unexpected stall!");
        assert(fwd_data[0] == reg_file[5]) else $error("Op0 data mismatch!");
        assert(fwd_data[1] == reg_file[10]) else $error("Op1 data mismatch!");

        rf_read_count += 2;
        $display("  No hazard case: PASS");

        src_valid <= '0;
        @(posedge clk);
    endtask

    // Test 2: RAW hazard with bypass from stage 0 (EX)
    task test_ex_bypass();
        $display("\n=== Test 2: EX Stage Bypass ===");

        // Producer: writing to R5 in EX stage
        stage_dst_addr[0] <= 5;
        stage_dst_valid[0] <= 1'b1;
        stage_is_load[0] <= 1'b0;  // ALU op, not load
        stage_result[0] <= 64'hDEADBEEF;

        // Consumer: reading R5
        src_addr[0] <= 5;
        src_valid[0] <= 1'b1;
        rf_read_data[0] <= reg_file[5];  // Stale value

        @(posedge clk);
        #1;

        assert(!stall_needed) else $error("Unexpected stall for ALU-ALU!");
        assert(fwd_data[0] == 64'hDEADBEEF) else $error("Bypass data wrong!");

        bypass_count++;
        $display("  EX bypass: PASS (got %h)", fwd_data[0]);

        stage_dst_valid <= '0;
        src_valid <= '0;
        @(posedge clk);
    endtask

    // Test 3: Load-use hazard (should stall)
    task test_load_use_hazard();
        $display("\n=== Test 3: Load-Use Hazard ===");

        if (!STALL_ON_LOAD) begin
            $display("  SKIPPED (STALL_ON_LOAD disabled)");
            return;
        end

        // Load in EX stage writing to R7
        stage_dst_addr[0] <= 7;
        stage_dst_valid[0] <= 1'b1;
        stage_is_load[0] <= 1'b1;  // This is a LOAD
        stage_result[0] <= 64'hCAFEBABE;  // Not available yet!

        // Consumer wants R7 immediately
        src_addr[0] <= 7;
        src_valid[0] <= 1'b1;

        @(posedge clk);
        #1;

        assert(stall_needed) else $error("Should stall on load-use!");
        stall_count++;
        $display("  Load-use stall: PASS");

        // After stall, load moves to MEM stage
        stage_dst_addr[0] <= 0;
        stage_dst_valid[0] <= 1'b0;
        stage_is_load[0] <= 1'b0;
        stage_dst_addr[1] <= 7;
        stage_dst_valid[1] <= 1'b1;
        stage_result[1] <= 64'hCAFEBABE;

        @(posedge clk);
        #1;

        assert(!stall_needed) else $error("Should not stall after 1 cycle!");
        assert(fwd_data[0] == 64'hCAFEBABE) else $error("MEM bypass failed!");

        bypass_count++;
        $display("  MEM bypass after stall: PASS");

        stage_dst_valid <= '0;
        src_valid <= '0;
        @(posedge clk);
    endtask

    // Test 4: Multiple operand forwarding
    task test_multi_operand();
        $display("\n=== Test 4: Multiple Operand Forwarding ===");

        // Two different producers in different stages
        stage_dst_addr[0] <= 3;
        stage_dst_valid[0] <= 1'b1;
        stage_result[0] <= 64'h1111;

        stage_dst_addr[1] <= 8;
        stage_dst_valid[1] <= 1'b1;
        stage_result[1] <= 64'h2222;

        // Consumer needs both
        src_addr[0] <= 3;
        src_addr[1] <= 8;
        src_valid <= '1;

        @(posedge clk);
        #1;

        assert(fwd_data[0] == 64'h1111) else $error("Op0 bypass failed!");
        assert(fwd_data[1] == 64'h2222) else $error("Op1 bypass failed!");

        bypass_count += 2;
        $display("  Multi-operand: PASS");

        stage_dst_valid <= '0;
        src_valid <= '0;
        @(posedge clk);
    endtask

    // Test 5: Bypass priority (closer stage wins)
    task test_bypass_priority();
        $display("\n=== Test 5: Bypass Priority ===");

        // Same register in multiple stages (older = higher stage number)
        stage_dst_addr[0] <= 12;
        stage_dst_valid[0] <= 1'b1;
        stage_result[0] <= 64'hAAAA;  // Most recent

        stage_dst_addr[1] <= 12;
        stage_dst_valid[1] <= 1'b1;
        stage_result[1] <= 64'hBBBB;  // Older

        src_addr[0] <= 12;
        src_valid[0] <= 1'b1;

        @(posedge clk);
        #1;

        assert(fwd_data[0] == 64'hAAAA) else $error("Should get EX result, not MEM!");

        bypass_count++;
        $display("  Priority (EX over MEM): PASS");

        stage_dst_valid <= '0;
        src_valid <= '0;
        @(posedge clk);
    endtask

    //--------------------------------------------------------------------------
    // Main Test
    //--------------------------------------------------------------------------
    initial begin
        $display("\n");
        $display("==============================================================");
        $display("  Pipeline Bypass Network Testbench");
        $display("  NUM_STAGES=%0d, NUM_OPERANDS=%0d", NUM_STAGES, NUM_OPERANDS);
        $display("==============================================================");

        reset_dut();

        test_no_hazard();
        test_ex_bypass();
        test_load_use_hazard();
        test_multi_operand();
        test_bypass_priority();

        $display("\n");
        $display("==============================================================");
        $display("  Summary:");
        $display("    Bypass forwards: %0d", bypass_count);
        $display("    Load-use stalls: %0d", stall_count);
        $display("    RF reads: %0d", rf_read_count);
        $display("==============================================================");
        $display("\n");

        $finish;
    end

    // Timeout
    initial begin
        #(CLK_PERIOD_NS * 10000);
        $error("Global timeout!");
        $finish;
    end

endmodule
