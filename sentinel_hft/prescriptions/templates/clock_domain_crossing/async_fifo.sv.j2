//==============================================================================
// Asynchronous FIFO with Gray Code Pointers
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: CLOCK_DOMAIN_CROSSING
//
// Parameters:
//   DATA_WIDTH = {{ params.DATA_WIDTH }}
//   DEPTH = {{ params.DEPTH }}
//   SYNC_STAGES = {{ params.SYNC_STAGES }}
//   ALMOST_FULL_THRESHOLD = {{ params.ALMOST_FULL_THRESHOLD }}
//   ALMOST_EMPTY_THRESHOLD = {{ params.ALMOST_EMPTY_THRESHOLD }}
//   OUTPUT_REG = {{ params.OUTPUT_REG }}
//
// Expected Impact:
//   Latency reduction: ~{{ metadata.expected_latency_reduction_pct }}%
//   Throughput improvement: ~{{ metadata.expected_throughput_improvement_pct }}%
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

module async_fifo #(
    parameter int DATA_WIDTH = {{ params.DATA_WIDTH }},
    parameter int DEPTH = {{ params.DEPTH }},
    parameter int SYNC_STAGES = {{ params.SYNC_STAGES }},
    parameter int ALMOST_FULL_THRESHOLD = {{ params.ALMOST_FULL_THRESHOLD }},
    parameter int ALMOST_EMPTY_THRESHOLD = {{ params.ALMOST_EMPTY_THRESHOLD }},
    parameter bit OUTPUT_REG = {{ '1' if params.OUTPUT_REG else '0' }}
) (
    // Write domain
    input  logic                    wr_clk,
    input  logic                    wr_rst_n,
    input  logic [DATA_WIDTH-1:0]   wr_data,
    input  logic                    wr_en,
    output logic                    wr_full,
    output logic                    wr_almost_full,

    // Read domain
    input  logic                    rd_clk,
    input  logic                    rd_rst_n,
    output logic [DATA_WIDTH-1:0]   rd_data,
    input  logic                    rd_en,
    output logic                    rd_empty,
    output logic                    rd_almost_empty,

    // Status (optional, in write domain)
    output logic [$clog2(DEPTH):0]  wr_fill_level
);

    //--------------------------------------------------------------------------
    // Local Parameters
    //--------------------------------------------------------------------------
    localparam int ADDR_WIDTH = $clog2(DEPTH);
    localparam int PTR_WIDTH = ADDR_WIDTH + 1;  // Extra bit for wrap detection

    //--------------------------------------------------------------------------
    // Functions
    //--------------------------------------------------------------------------
    function automatic [PTR_WIDTH-1:0] bin_to_gray(input [PTR_WIDTH-1:0] bin);
        return bin ^ (bin >> 1);
    endfunction

    function automatic [PTR_WIDTH-1:0] gray_to_bin(input [PTR_WIDTH-1:0] gray);
        logic [PTR_WIDTH-1:0] bin;
        bin[PTR_WIDTH-1] = gray[PTR_WIDTH-1];
        for (int i = PTR_WIDTH-2; i >= 0; i--) begin
            bin[i] = bin[i+1] ^ gray[i];
        end
        return bin;
    endfunction

    //--------------------------------------------------------------------------
    // Memory
    //--------------------------------------------------------------------------
    (* ram_style = "distributed" *)
    logic [DATA_WIDTH-1:0] mem [DEPTH];

    //--------------------------------------------------------------------------
    // Write Domain
    //--------------------------------------------------------------------------
    logic [PTR_WIDTH-1:0] wr_ptr_bin;
    logic [PTR_WIDTH-1:0] wr_ptr_gray;
    logic [PTR_WIDTH-1:0] rd_ptr_gray_sync;
    logic [PTR_WIDTH-1:0] rd_ptr_bin_sync;

    // Write pointer (binary and gray)
    always_ff @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n) begin
            wr_ptr_bin <= '0;
            wr_ptr_gray <= '0;
        end else if (wr_en && !wr_full) begin
            wr_ptr_bin <= wr_ptr_bin + 1'b1;
            wr_ptr_gray <= bin_to_gray(wr_ptr_bin + 1'b1);
        end
    end

    // Memory write
    always_ff @(posedge wr_clk) begin
        if (wr_en && !wr_full) begin
            mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= wr_data;
        end
    end

    // Synchronize read pointer to write domain
    (* ASYNC_REG = "TRUE" *)
    logic [PTR_WIDTH-1:0] rd_ptr_gray_meta [SYNC_STAGES];

    always_ff @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n) begin
            for (int i = 0; i < SYNC_STAGES; i++) begin
                rd_ptr_gray_meta[i] <= '0;
            end
        end else begin
            rd_ptr_gray_meta[0] <= rd_ptr_gray;
            for (int i = 1; i < SYNC_STAGES; i++) begin
                rd_ptr_gray_meta[i] <= rd_ptr_gray_meta[i-1];
            end
        end
    end

    assign rd_ptr_gray_sync = rd_ptr_gray_meta[SYNC_STAGES-1];
    assign rd_ptr_bin_sync = gray_to_bin(rd_ptr_gray_sync);

    // Full detection (in write domain)
    // Full when wr_ptr and rd_ptr are same except MSB
    assign wr_full = (wr_ptr_gray == {~rd_ptr_gray_sync[PTR_WIDTH-1:PTR_WIDTH-2],
                                       rd_ptr_gray_sync[PTR_WIDTH-3:0]});

    // Almost full (conservative)
    logic [PTR_WIDTH-1:0] wr_fill;
    assign wr_fill = wr_ptr_bin - rd_ptr_bin_sync;
    assign wr_almost_full = (wr_fill >= (DEPTH - ALMOST_FULL_THRESHOLD));
    assign wr_fill_level = wr_fill;

    //--------------------------------------------------------------------------
    // Read Domain
    //--------------------------------------------------------------------------
    logic [PTR_WIDTH-1:0] rd_ptr_bin;
    logic [PTR_WIDTH-1:0] rd_ptr_gray;
    logic [PTR_WIDTH-1:0] wr_ptr_gray_sync;
    logic [PTR_WIDTH-1:0] wr_ptr_bin_sync;

    // Read pointer (binary and gray)
    always_ff @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n) begin
            rd_ptr_bin <= '0;
            rd_ptr_gray <= '0;
        end else if (rd_en && !rd_empty) begin
            rd_ptr_bin <= rd_ptr_bin + 1'b1;
            rd_ptr_gray <= bin_to_gray(rd_ptr_bin + 1'b1);
        end
    end

    // Synchronize write pointer to read domain
    (* ASYNC_REG = "TRUE" *)
    logic [PTR_WIDTH-1:0] wr_ptr_gray_meta [SYNC_STAGES];

    always_ff @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n) begin
            for (int i = 0; i < SYNC_STAGES; i++) begin
                wr_ptr_gray_meta[i] <= '0;
            end
        end else begin
            wr_ptr_gray_meta[0] <= wr_ptr_gray;
            for (int i = 1; i < SYNC_STAGES; i++) begin
                wr_ptr_gray_meta[i] <= wr_ptr_gray_meta[i-1];
            end
        end
    end

    assign wr_ptr_gray_sync = wr_ptr_gray_meta[SYNC_STAGES-1];
    assign wr_ptr_bin_sync = gray_to_bin(wr_ptr_gray_sync);

    // Empty detection (in read domain)
    assign rd_empty = (rd_ptr_gray == wr_ptr_gray_sync);

    // Almost empty
    logic [PTR_WIDTH-1:0] rd_fill;
    assign rd_fill = wr_ptr_bin_sync - rd_ptr_bin;
    assign rd_almost_empty = (rd_fill <= ALMOST_EMPTY_THRESHOLD);

    //--------------------------------------------------------------------------
    // Read Data Output
    //--------------------------------------------------------------------------
    generate
        if (OUTPUT_REG) begin : gen_reg_output
            // Registered output for better timing
            logic [DATA_WIDTH-1:0] rd_data_reg;
            logic                  rd_valid_reg;

            always_ff @(posedge rd_clk or negedge rd_rst_n) begin
                if (!rd_rst_n) begin
                    rd_data_reg <= '0;
                    rd_valid_reg <= 1'b0;
                end else if (rd_en && !rd_empty) begin
                    rd_data_reg <= mem[rd_ptr_bin[ADDR_WIDTH-1:0]];
                    rd_valid_reg <= 1'b1;
                end else begin
                    rd_valid_reg <= 1'b0;
                end
            end

            assign rd_data = rd_data_reg;
        end else begin : gen_comb_output
            // Combinational output (lower latency)
            assign rd_data = mem[rd_ptr_bin[ADDR_WIDTH-1:0]];
        end
    endgenerate

    //--------------------------------------------------------------------------
    // Assertions
    //--------------------------------------------------------------------------
`ifdef SIMULATION
    // synthesis translate_off

    // Depth must be power of 2
    initial begin
        assert ((DEPTH & (DEPTH-1)) == 0)
            else $fatal("DEPTH must be power of 2!");
    end

    // No write when full
    assert property (@(posedge wr_clk) disable iff (!wr_rst_n)
        wr_full |-> !wr_en
    ) else $warning("Write attempted when full!");

    // No read when empty
    assert property (@(posedge rd_clk) disable iff (!rd_rst_n)
        rd_empty |-> !rd_en
    ) else $warning("Read attempted when empty!");

    // synthesis translate_on
`endif

endmodule
