//==============================================================================
// Asynchronous FIFO Testbench
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: CLOCK_DOMAIN_CROSSING
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

`timescale 1ns/1ps

module async_fifo_tb;

    //--------------------------------------------------------------------------
    // Parameters
    //--------------------------------------------------------------------------
    localparam int DATA_WIDTH = {{ params.DATA_WIDTH }};
    localparam int DEPTH = {{ params.DEPTH }};
    localparam int SYNC_STAGES = {{ params.SYNC_STAGES }};
    localparam int ALMOST_FULL_THRESHOLD = {{ params.ALMOST_FULL_THRESHOLD }};
    localparam int ALMOST_EMPTY_THRESHOLD = {{ params.ALMOST_EMPTY_THRESHOLD }};
    localparam bit OUTPUT_REG = {{ '1' if params.OUTPUT_REG else '0' }};

    // Clock periods (different frequencies to stress CDC)
    localparam real WR_CLK_PERIOD = 8.0;   // 125 MHz
    localparam real RD_CLK_PERIOD = 10.0;  // 100 MHz

    //--------------------------------------------------------------------------
    // Signals
    //--------------------------------------------------------------------------
    logic                    wr_clk;
    logic                    wr_rst_n;
    logic [DATA_WIDTH-1:0]   wr_data;
    logic                    wr_en;
    logic                    wr_full;
    logic                    wr_almost_full;

    logic                    rd_clk;
    logic                    rd_rst_n;
    logic [DATA_WIDTH-1:0]   rd_data;
    logic                    rd_en;
    logic                    rd_empty;
    logic                    rd_almost_empty;

    logic [$clog2(DEPTH):0]  wr_fill_level;

    //--------------------------------------------------------------------------
    // DUT
    //--------------------------------------------------------------------------
    async_fifo #(
        .DATA_WIDTH(DATA_WIDTH),
        .DEPTH(DEPTH),
        .SYNC_STAGES(SYNC_STAGES),
        .ALMOST_FULL_THRESHOLD(ALMOST_FULL_THRESHOLD),
        .ALMOST_EMPTY_THRESHOLD(ALMOST_EMPTY_THRESHOLD),
        .OUTPUT_REG(OUTPUT_REG)
    ) dut (.*);

    //--------------------------------------------------------------------------
    // Clocks (different frequencies)
    //--------------------------------------------------------------------------
    initial begin
        wr_clk = 0;
        forever #(WR_CLK_PERIOD/2) wr_clk = ~wr_clk;
    end

    initial begin
        rd_clk = 0;
        forever #(RD_CLK_PERIOD/2) rd_clk = ~rd_clk;
    end

    //--------------------------------------------------------------------------
    // Reference Model
    //--------------------------------------------------------------------------
    logic [DATA_WIDTH-1:0] expected_queue[$];
    int write_count;
    int read_count;
    int error_count;

    //--------------------------------------------------------------------------
    // Test Tasks
    //--------------------------------------------------------------------------
    task reset_fifos();
        wr_rst_n <= 1'b0;
        rd_rst_n <= 1'b0;
        wr_data <= '0;
        wr_en <= 1'b0;
        rd_en <= 1'b0;
        expected_queue.delete();
        write_count = 0;
        read_count = 0;
        error_count = 0;

        repeat(20) @(posedge wr_clk);
        wr_rst_n <= 1'b1;
        repeat(20) @(posedge rd_clk);
        rd_rst_n <= 1'b1;
        repeat(10) @(posedge wr_clk);
    endtask

    // Writer process
    task automatic writer(int num_writes, int gap_prob = 0);
        for (int i = 0; i < num_writes; i++) begin
            // Wait for not full
            while (wr_full) @(posedge wr_clk);

            // Random gaps
            if ($urandom_range(100) < gap_prob) begin
                wr_en <= 1'b0;
                repeat($urandom_range(1, 5)) @(posedge wr_clk);
            end

            wr_data <= $urandom();
            wr_en <= 1'b1;
            expected_queue.push_back(wr_data);
            write_count++;
            @(posedge wr_clk);
        end
        wr_en <= 1'b0;
    endtask

    // Reader process
    task automatic reader(int num_reads, int gap_prob = 0);
        logic [DATA_WIDTH-1:0] expected;

        for (int i = 0; i < num_reads; i++) begin
            // Wait for not empty
            while (rd_empty) @(posedge rd_clk);

            // Random gaps
            if ($urandom_range(100) < gap_prob) begin
                rd_en <= 1'b0;
                repeat($urandom_range(1, 5)) @(posedge rd_clk);
            end

            rd_en <= 1'b1;
            @(posedge rd_clk);

            // Verify data (with latency for OUTPUT_REG)
            if (OUTPUT_REG) @(posedge rd_clk);

            if (expected_queue.size() > 0) begin
                expected = expected_queue.pop_front();
                if (rd_data !== expected) begin
                    $error("Data mismatch! Expected: %h, Got: %h", expected, rd_data);
                    error_count++;
                end
            end
            read_count++;
        end
        rd_en <= 1'b0;
    endtask

    // Test 1: Basic write then read
    task test_basic();
        $display("\n=== Test 1: Basic Write/Read ===");

        fork
            writer(16, 0);
        join

        // Let writes settle
        repeat(SYNC_STAGES * 3) @(posedge rd_clk);

        fork
            reader(16, 0);
        join

        repeat(10) @(posedge rd_clk);

        $display("  Writes: %0d, Reads: %0d, Errors: %0d",
                 write_count, read_count, error_count);
        $display("  Basic test: %s", (error_count == 0) ? "PASS" : "FAIL");
    endtask

    // Test 2: Concurrent write and read
    task test_concurrent();
        $display("\n=== Test 2: Concurrent Write/Read ===");

        error_count = 0;
        write_count = 0;
        read_count = 0;

        fork
            writer({{ metadata.min_test_vectors }}, 10);  // 10% gaps
            reader({{ metadata.min_test_vectors }}, 10);
        join

        repeat(50) @(posedge rd_clk);

        $display("  Writes: %0d, Reads: %0d, Errors: %0d",
                 write_count, read_count, error_count);
        $display("  Concurrent test: %s", (error_count == 0) ? "PASS" : "FAIL");
    endtask

    // Test 3: Fill to full
    task test_full();
        $display("\n=== Test 3: Fill to Full ===");

        error_count = 0;
        expected_queue.delete();

        // Fill FIFO
        for (int i = 0; i < DEPTH; i++) begin
            while (wr_full) @(posedge wr_clk);
            wr_data <= i;
            wr_en <= 1'b1;
            expected_queue.push_back(i);
            @(posedge wr_clk);
        end
        wr_en <= 1'b0;

        // Wait for pointers to sync
        repeat(SYNC_STAGES * 3) @(posedge wr_clk);

        $display("  After fill: wr_full=%b, wr_fill_level=%0d",
                 wr_full, wr_fill_level);

        // Drain FIFO
        for (int i = 0; i < DEPTH; i++) begin
            while (rd_empty) @(posedge rd_clk);
            rd_en <= 1'b1;
            @(posedge rd_clk);
        end
        rd_en <= 1'b0;

        repeat(SYNC_STAGES * 3) @(posedge rd_clk);

        $display("  After drain: rd_empty=%b", rd_empty);
        $display("  Full/drain test: %s", rd_empty ? "PASS" : "FAIL");
    endtask

    // Test 4: Almost full/empty flags
    task test_almost_flags();
        $display("\n=== Test 4: Almost Full/Empty Flags ===");

        // Fill to almost full
        for (int i = 0; i < DEPTH - ALMOST_FULL_THRESHOLD + 1; i++) begin
            while (wr_full) @(posedge wr_clk);
            wr_data <= i;
            wr_en <= 1'b1;
            @(posedge wr_clk);
        end
        wr_en <= 1'b0;

        repeat(SYNC_STAGES * 3) @(posedge wr_clk);

        $display("  Almost full triggered at fill=%0d: %s",
                 wr_fill_level, wr_almost_full ? "YES" : "NO");

        // Drain to almost empty
        while (!rd_almost_empty && !rd_empty) begin
            rd_en <= 1'b1;
            @(posedge rd_clk);
        end
        rd_en <= 1'b0;

        $display("  Almost empty triggered: %s", rd_almost_empty ? "YES" : "NO");
    endtask

    // Test 5: Stress with frequency ratio
    task test_freq_stress();
        $display("\n=== Test 5: Frequency Stress ===");
        $display("  Write CLK: %0.1f MHz, Read CLK: %0.1f MHz",
                 1000.0/WR_CLK_PERIOD, 1000.0/RD_CLK_PERIOD);

        error_count = 0;
        write_count = 0;
        read_count = 0;
        expected_queue.delete();

        // Fast writer, slow reader (or vice versa)
        fork
            writer(500, 5);
            reader(500, 5);
        join

        repeat(100) @(posedge rd_clk);

        $display("  Transfers: %0d, Errors: %0d", read_count, error_count);
        $display("  Frequency stress: %s", (error_count == 0) ? "PASS" : "FAIL");
    endtask

    //--------------------------------------------------------------------------
    // Main Test
    //--------------------------------------------------------------------------
    initial begin
        $display("\n");
        $display("==============================================================");
        $display("  Asynchronous FIFO Testbench");
        $display("  DEPTH=%0d, SYNC_STAGES=%0d", DEPTH, SYNC_STAGES);
        $display("  WR_CLK=%0.1fMHz, RD_CLK=%0.1fMHz",
                 1000.0/WR_CLK_PERIOD, 1000.0/RD_CLK_PERIOD);
        $display("==============================================================");

        reset_fifos();

        test_basic();
        reset_fifos();

        test_concurrent();
        reset_fifos();

        test_full();
        reset_fifos();

        test_almost_flags();
        reset_fifos();

        test_freq_stress();

        $display("\n");
        $display("==============================================================");
        $display("  All tests completed");
        $display("==============================================================");
        $display("\n");

        $finish;
    end

    // Timeout
    initial begin
        #(WR_CLK_PERIOD * 100000);
        $error("Global timeout!");
        $finish;
    end

endmodule
