//==============================================================================
// Weighted Round-Robin Arbiter with Priority Escalation
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: ARBITER_CONTENTION
//
// Parameters:
//   NUM_PORTS = {{ params.NUM_PORTS }}
//   DATA_WIDTH = {{ params.DATA_WIDTH }}
//   WEIGHT_WIDTH = {{ params.WEIGHT_WIDTH }}
//   ENABLE_PRIORITY_ESCALATION = {{ params.ENABLE_PRIORITY_ESCALATION }}
//   ESCALATION_THRESHOLD = {{ params.ESCALATION_THRESHOLD }}
//   SINGLE_CYCLE_GRANT = {{ params.SINGLE_CYCLE_GRANT }}
//
// Expected Impact:
//   Latency reduction: ~{{ metadata.expected_latency_reduction_pct }}%
//   Throughput improvement: ~{{ metadata.expected_throughput_improvement_pct }}%
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

module weighted_rr_arbiter #(
    parameter int NUM_PORTS = {{ params.NUM_PORTS }},
    parameter int DATA_WIDTH = {{ params.DATA_WIDTH }},
    parameter int WEIGHT_WIDTH = {{ params.WEIGHT_WIDTH }},
    parameter bit ENABLE_ESCALATION = {{ '1' if params.ENABLE_PRIORITY_ESCALATION else '0' }},
    parameter int ESCALATION_THRESHOLD = {{ params.ESCALATION_THRESHOLD }},
    parameter bit SINGLE_CYCLE_GRANT = {{ '1' if params.SINGLE_CYCLE_GRANT else '0' }}
) (
    input  logic                          clk,
    input  logic                          rst_n,

    // Requester interfaces
    input  logic [NUM_PORTS-1:0]          req,
    input  logic [NUM_PORTS-1:0][DATA_WIDTH-1:0] req_data,
    output logic [NUM_PORTS-1:0]          grant,

    // Weight configuration (set during init)
    input  logic [NUM_PORTS-1:0][WEIGHT_WIDTH-1:0] weights,

    // Granted output
    output logic [DATA_WIDTH-1:0]         grant_data,
    output logic                          grant_valid,
    input  logic                          grant_ready,

    // Status
    output logic [$clog2(NUM_PORTS)-1:0]  current_winner,
    output logic [NUM_PORTS-1:0]          starvation_warning
);

    //--------------------------------------------------------------------------
    // Local Parameters
    //--------------------------------------------------------------------------
    localparam int PORT_BITS = $clog2(NUM_PORTS);
    localparam int MAX_WEIGHT = (1 << WEIGHT_WIDTH) - 1;

    //--------------------------------------------------------------------------
    // Internal Signals
    //--------------------------------------------------------------------------
    logic [PORT_BITS-1:0]           rr_pointer;
    logic [NUM_PORTS-1:0][WEIGHT_WIDTH-1:0] weight_counters;
    logic [NUM_PORTS-1:0]           eligible;
    logic [NUM_PORTS-1:0]           rotated_req;
    logic [NUM_PORTS-1:0]           rotated_eligible;
    logic [PORT_BITS-1:0]           winner;
    logic                           any_request;

    // Priority escalation
    generate if (ENABLE_ESCALATION) begin : gen_escalation
        logic [NUM_PORTS-1:0][7:0] wait_counters;
        logic [NUM_PORTS-1:0]      escalated;
    end endgenerate

    //--------------------------------------------------------------------------
    // Request Detection
    //--------------------------------------------------------------------------
    assign any_request = |req;

    //--------------------------------------------------------------------------
    // Eligibility (based on remaining weight credits)
    //--------------------------------------------------------------------------
    always_comb begin
        for (int i = 0; i < NUM_PORTS; i++) begin
            eligible[i] = req[i] && (weight_counters[i] > 0);
        end
    end

    //--------------------------------------------------------------------------
    // Round-Robin Rotation
    //--------------------------------------------------------------------------
    // Rotate requests and eligibility based on current pointer
    always_comb begin
        for (int i = 0; i < NUM_PORTS; i++) begin
            int idx = (i + rr_pointer) % NUM_PORTS;
            rotated_req[i] = req[idx];
            rotated_eligible[i] = eligible[idx];
        end
    end

    //--------------------------------------------------------------------------
    // Winner Selection
    //--------------------------------------------------------------------------
    always_comb begin
        winner = rr_pointer;

        // Priority 1: Eligible requests (have weight credits)
        for (int i = 0; i < NUM_PORTS; i++) begin
            if (rotated_eligible[i]) begin
                winner = (i + rr_pointer) % NUM_PORTS;
                break;
            end
        end

        // Priority 2: If no eligible, any request (weights exhausted)
        if (!|eligible && any_request) begin
            for (int i = 0; i < NUM_PORTS; i++) begin
                if (rotated_req[i]) begin
                    winner = (i + rr_pointer) % NUM_PORTS;
                    break;
                end
            end
        end

        // Priority 3: Escalated requests (starvation prevention)
        if (ENABLE_ESCALATION) begin
            for (int i = 0; i < NUM_PORTS; i++) begin
                if (req[i] && gen_escalation.escalated[i]) begin
                    winner = i;
                    break;
                end
            end
        end
    end

    //--------------------------------------------------------------------------
    // Grant Generation
    //--------------------------------------------------------------------------
    generate
        if (SINGLE_CYCLE_GRANT) begin : gen_fast_grant
            // Combinational grant for single-requester case
            logic single_req;
            logic [PORT_BITS-1:0] single_req_idx;

            always_comb begin
                single_req = 1'b0;
                single_req_idx = '0;

                // Check if exactly one requester
                if (any_request && ($countones(req) == 1)) begin
                    single_req = 1'b1;
                    for (int i = 0; i < NUM_PORTS; i++) begin
                        if (req[i]) single_req_idx = i;
                    end
                end
            end

            always_comb begin
                grant = '0;
                if (any_request && grant_ready) begin
                    if (single_req) begin
                        grant[single_req_idx] = 1'b1;
                    end else begin
                        grant[winner] = 1'b1;
                    end
                end
            end
        end else begin : gen_registered_grant
            // Registered grant
            always_ff @(posedge clk or negedge rst_n) begin
                if (!rst_n) begin
                    grant <= '0;
                end else begin
                    grant <= '0;
                    if (any_request && grant_ready) begin
                        grant[winner] <= 1'b1;
                    end
                end
            end
        end
    endgenerate

    //--------------------------------------------------------------------------
    // Grant Data Mux
    //--------------------------------------------------------------------------
    always_comb begin
        grant_data = req_data[winner];
        grant_valid = |grant;
        current_winner = winner;
    end

    //--------------------------------------------------------------------------
    // Round-Robin Pointer Update
    //--------------------------------------------------------------------------
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rr_pointer <= '0;
        end else if (|grant && grant_ready) begin
            // Move to next port after grant
            rr_pointer <= (winner + 1) % NUM_PORTS;
        end
    end

    //--------------------------------------------------------------------------
    // Weight Counter Management
    //--------------------------------------------------------------------------
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < NUM_PORTS; i++) begin
                weight_counters[i] <= weights[i];
            end
        end else begin
            // Decrement winner's weight
            if (grant[winner] && grant_ready) begin
                if (weight_counters[winner] > 0) begin
                    weight_counters[winner] <= weight_counters[winner] - 1'b1;
                end
            end

            // Refill all weights when round completes (all weights exhausted)
            if (!|eligible || (grant[winner] && weight_counters[winner] == 1)) begin
                for (int i = 0; i < NUM_PORTS; i++) begin
                    weight_counters[i] <= weights[i];
                end
            end
        end
    end

    //--------------------------------------------------------------------------
    // Priority Escalation (Starvation Prevention)
    //--------------------------------------------------------------------------
    generate if (ENABLE_ESCALATION) begin : gen_escalation_logic
        always_ff @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                gen_escalation.wait_counters <= '0;
                gen_escalation.escalated <= '0;
            end else begin
                for (int i = 0; i < NUM_PORTS; i++) begin
                    if (req[i] && !grant[i]) begin
                        // Increment wait counter
                        if (gen_escalation.wait_counters[i] < ESCALATION_THRESHOLD) begin
                            gen_escalation.wait_counters[i] <= gen_escalation.wait_counters[i] + 1'b1;
                        end else begin
                            gen_escalation.escalated[i] <= 1'b1;
                        end
                    end else if (grant[i]) begin
                        // Reset on grant
                        gen_escalation.wait_counters[i] <= '0;
                        gen_escalation.escalated[i] <= 1'b0;
                    end
                end
            end
        end

        assign starvation_warning = gen_escalation.escalated;
    end else begin : gen_no_escalation
        assign starvation_warning = '0;
    end endgenerate

    //--------------------------------------------------------------------------
    // Assertions (for simulation)
    //--------------------------------------------------------------------------
`ifdef SIMULATION
    // synthesis translate_off

    // At most one grant at a time
    assert property (@(posedge clk) disable iff (!rst_n)
        $countones(grant) <= 1
    ) else $error("Multiple grants!");

    // Grant only when request present
    assert property (@(posedge clk) disable iff (!rst_n)
        |grant |-> |req
    ) else $error("Grant without request!");

    // No starvation (if escalation enabled)
    generate if (ENABLE_ESCALATION) begin
        assert property (@(posedge clk) disable iff (!rst_n)
            req[0] && gen_escalation.escalated[0] |-> ##[1:10] grant[0]
        ) else $warning("Potential starvation on port 0");
    end endgenerate

    // synthesis translate_on
`endif

endmodule
