# Integration Guide: Prefetch Buffer

> **Generated by Sentinel-HFT FixPack Generator**
> Pattern: MEMORY_BANDWIDTH
> Generated: {{ metadata.generation_timestamp }}

## Overview

This fix addresses **memory bandwidth** bottlenecks by implementing stride-detecting prefetch to hide memory latency.

### Problem Statement

{{ metadata.problem_statement }}

### Solution Approach

{{ metadata.solution_approach }}

## Parameters Used

| Parameter | Value | Description |
|-----------|-------|-------------|
| DATA_WIDTH | {{ params.DATA_WIDTH }} | Memory data width |
| ADDR_WIDTH | {{ params.ADDR_WIDTH }} | Address width |
| PREFETCH_DEPTH | {{ params.PREFETCH_DEPTH }} | Prefetch entries |
| STRIDE_HISTORY | {{ params.STRIDE_HISTORY }} | Addresses for stride detection |
| CONFIDENCE_THRESHOLD | {{ params.CONFIDENCE_THRESHOLD }} | Min confidence to prefetch |
| MAX_OUTSTANDING | {{ params.MAX_OUTSTANDING }} | Max outstanding requests |

## Expected Impact

- **Latency Reduction**: ~{{ metadata.expected_latency_reduction_pct }}%
- **Throughput Improvement**: ~{{ metadata.expected_throughput_improvement_pct }}%

## Integration Steps

### Step 1: Insert Between Core and Memory Controller

```systemverilog
prefetch_buffer #(
    .DATA_WIDTH({{ params.DATA_WIDTH }}),
    .ADDR_WIDTH({{ params.ADDR_WIDTH }}),
    .PREFETCH_DEPTH({{ params.PREFETCH_DEPTH }}),
    .STRIDE_HISTORY({{ params.STRIDE_HISTORY }}),
    .CONFIDENCE_THRESHOLD({{ params.CONFIDENCE_THRESHOLD }}),
    .MAX_OUTSTANDING({{ params.MAX_OUTSTANDING }}),
    .AXI_ID_WIDTH({{ params.AXI_ID_WIDTH }})
) u_prefetch (
    .clk(clk),
    .rst_n(rst_n),

    // Core side
    .demand_addr(core_mem_addr),
    .demand_valid(core_mem_req),
    .demand_ready(core_mem_ready),
    .demand_data(core_mem_rdata),
    .demand_data_valid(core_mem_rvalid),
    .demand_hit(prefetch_hit),

    // Memory controller side (AXI)
    .axi_arid(mem_arid),
    .axi_araddr(mem_araddr),
    .axi_arlen(mem_arlen),
    .axi_arsize(mem_arsize),
    .axi_arburst(mem_arburst),
    .axi_arvalid(mem_arvalid),
    .axi_arready(mem_arready),

    .axi_rid(mem_rid),
    .axi_rdata(mem_rdata),
    .axi_rresp(mem_rresp),
    .axi_rlast(mem_rlast),
    .axi_rvalid(mem_rvalid),
    .axi_rready(mem_rready),

    // Monitoring
    .prefetch_confidence(perf_prefetch_confidence),
    .buffer_occupancy(perf_buffer_fill),
    .stride_detected(perf_stride_active)
);
```

### Step 2: Monitor Prefetch Effectiveness

```systemverilog
// Track hit rate for tuning
always_ff @(posedge clk) begin
    if (core_mem_req && core_mem_ready) begin
        total_accesses <= total_accesses + 1;
        if (prefetch_hit) hit_count <= hit_count + 1;
    end
end

assign prefetch_hit_rate = (hit_count * 100) / total_accesses;
```

### Step 3: AXI ID Management

Ensure your memory controller can handle tagged requests:

```systemverilog
// Prefetch uses IDs 0 to MAX_OUTSTANDING-1
// Reserve higher IDs for non-prefetchable traffic
assign other_traffic_id = {{ params.MAX_OUTSTANDING }} + local_id;
```

## Verification Checklist

- [ ] Sequential access shows >50% hit rate after warmup
- [ ] Strided access triggers stride detection
- [ ] Random access shows ~0% hit rate (no wasted bandwidth)
- [ ] No data corruption (prefetched data matches demand)
- [ ] Outstanding request limit respected

## Tuning Recommendations

1. **Increase PREFETCH_DEPTH** if hit rate is low but stride is detected
2. **Increase CONFIDENCE_THRESHOLD** if random traffic causes bad prefetches
3. **Decrease MAX_OUTSTANDING** if memory bandwidth is constrained

---

**CANDIDATE FIX - Review Required Before Use**
