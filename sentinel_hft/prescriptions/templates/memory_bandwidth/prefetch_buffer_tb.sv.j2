//==============================================================================
// Prefetch Buffer Testbench
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: MEMORY_BANDWIDTH
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

`timescale 1ns/1ps

module prefetch_buffer_tb;

    //--------------------------------------------------------------------------
    // Parameters
    //--------------------------------------------------------------------------
    localparam int DATA_WIDTH = {{ params.DATA_WIDTH }};
    localparam int ADDR_WIDTH = {{ params.ADDR_WIDTH }};
    localparam int PREFETCH_DEPTH = {{ params.PREFETCH_DEPTH }};
    localparam int STRIDE_HISTORY = {{ params.STRIDE_HISTORY }};
    localparam int CONFIDENCE_THRESHOLD = {{ params.CONFIDENCE_THRESHOLD }};
    localparam int MAX_OUTSTANDING = {{ params.MAX_OUTSTANDING }};
    localparam int AXI_ID_WIDTH = {{ params.AXI_ID_WIDTH }};

    localparam int CLK_PERIOD_NS = 10;
    localparam int MEM_LATENCY_CYCLES = 20;  // Simulate DDR latency

    //--------------------------------------------------------------------------
    // Signals
    //--------------------------------------------------------------------------
    logic                    clk;
    logic                    rst_n;

    // Demand interface
    logic [ADDR_WIDTH-1:0]   demand_addr;
    logic                    demand_valid;
    logic                    demand_ready;
    logic [DATA_WIDTH-1:0]   demand_data;
    logic                    demand_data_valid;
    logic                    demand_hit;

    // AXI interface
    logic [AXI_ID_WIDTH-1:0] axi_arid;
    logic [ADDR_WIDTH-1:0]   axi_araddr;
    logic [7:0]              axi_arlen;
    logic [2:0]              axi_arsize;
    logic [1:0]              axi_arburst;
    logic                    axi_arvalid;
    logic                    axi_arready;

    logic [AXI_ID_WIDTH-1:0] axi_rid;
    logic [DATA_WIDTH-1:0]   axi_rdata;
    logic [1:0]              axi_rresp;
    logic                    axi_rlast;
    logic                    axi_rvalid;
    logic                    axi_rready;

    // Status
    logic [3:0]              prefetch_confidence;
    logic [$clog2(PREFETCH_DEPTH):0] buffer_occupancy;
    logic                    stride_detected;

    //--------------------------------------------------------------------------
    // DUT
    //--------------------------------------------------------------------------
    prefetch_buffer #(
        .DATA_WIDTH(DATA_WIDTH),
        .ADDR_WIDTH(ADDR_WIDTH),
        .PREFETCH_DEPTH(PREFETCH_DEPTH),
        .STRIDE_HISTORY(STRIDE_HISTORY),
        .CONFIDENCE_THRESHOLD(CONFIDENCE_THRESHOLD),
        .MAX_OUTSTANDING(MAX_OUTSTANDING),
        .AXI_ID_WIDTH(AXI_ID_WIDTH)
    ) dut (.*);

    //--------------------------------------------------------------------------
    // Clock
    //--------------------------------------------------------------------------
    initial begin
        clk = 0;
        forever #(CLK_PERIOD_NS/2) clk = ~clk;
    end

    //--------------------------------------------------------------------------
    // Memory Model
    //--------------------------------------------------------------------------
    typedef struct {
        logic [AXI_ID_WIDTH-1:0] id;
        logic [ADDR_WIDTH-1:0]   addr;
        int                      ready_cycle;
    } pending_req_t;

    pending_req_t pending_reqs[$];
    int cycle_count;

    // Accept read requests
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            axi_arready <= 1'b1;
        end else begin
            // Random backpressure
            axi_arready <= ($urandom_range(100) > 10);

            if (axi_arvalid && axi_arready) begin
                pending_req_t req;
                req.id = axi_arid;
                req.addr = axi_araddr;
                req.ready_cycle = cycle_count + MEM_LATENCY_CYCLES + $urandom_range(5);
                pending_reqs.push_back(req);
            end
        end
    end

    // Return read data after latency
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            axi_rvalid <= 1'b0;
            axi_rdata <= '0;
            axi_rid <= '0;
            axi_rresp <= '0;
            axi_rlast <= 1'b1;
            cycle_count <= 0;
        end else begin
            cycle_count <= cycle_count + 1;
            axi_rvalid <= 1'b0;

            if (pending_reqs.size() > 0) begin
                if (pending_reqs[0].ready_cycle <= cycle_count) begin
                    pending_req_t req = pending_reqs.pop_front();
                    axi_rid <= req.id;
                    axi_rdata <= {req.addr[DATA_WIDTH/2-1:0], req.addr[DATA_WIDTH/2-1:0]};  // Pattern based on address
                    axi_rvalid <= 1'b1;
                    axi_rresp <= 2'b00;  // OKAY
                    axi_rlast <= 1'b1;
                end
            end
        end
    end

    //--------------------------------------------------------------------------
    // Statistics
    //--------------------------------------------------------------------------
    int total_requests;
    int hit_count;
    int miss_count;
    longint total_latency;
    int request_start_cycle;

    //--------------------------------------------------------------------------
    // Test Tasks
    //--------------------------------------------------------------------------
    task reset_dut();
        rst_n <= 1'b0;
        demand_addr <= '0;
        demand_valid <= 1'b0;
        total_requests = 0;
        hit_count = 0;
        miss_count = 0;
        total_latency = 0;
        pending_reqs.delete();
        repeat(20) @(posedge clk);
        rst_n <= 1'b1;
        repeat(10) @(posedge clk);
    endtask

    task automatic issue_demand(logic [ADDR_WIDTH-1:0] addr);
        demand_addr <= addr;
        demand_valid <= 1'b1;
        request_start_cycle = cycle_count;

        // Wait for ready
        while (!demand_ready) @(posedge clk);
        @(posedge clk);
        demand_valid <= 1'b0;

        // Record hit/miss
        total_requests++;
        if (demand_hit) begin
            hit_count++;
            total_latency += 1;  // Immediate hit
        end else begin
            miss_count++;
            // Wait for data
            while (!demand_data_valid) @(posedge clk);
            total_latency += (cycle_count - request_start_cycle);
        end
    endtask

    // Test 1: Sequential access pattern
    task test_sequential();
        $display("\n=== Test 1: Sequential Access ===");
        logic [ADDR_WIDTH-1:0] base_addr = 40'h1000;

        for (int i = 0; i < 32; i++) begin
            issue_demand(base_addr + i * (DATA_WIDTH/8));
            repeat(2) @(posedge clk);  // Small gap between requests
        end

        // Wait for all responses
        repeat(MEM_LATENCY_CYCLES * 2) @(posedge clk);

        $display("  Requests: %0d, Hits: %0d, Misses: %0d", total_requests, hit_count, miss_count);
        $display("  Hit rate: %0.1f%%", 100.0 * hit_count / total_requests);
        $display("  Avg latency: %0.1f cycles", real'(total_latency) / total_requests);
        $display("  Stride detected: %b, Confidence: %0d", stride_detected, prefetch_confidence);
    endtask

    // Test 2: Strided access pattern
    task test_strided();
        $display("\n=== Test 2: Strided Access (stride=256B) ===");
        logic [ADDR_WIDTH-1:0] base_addr = 40'h10000;
        int stride = 256;

        total_requests = 0;
        hit_count = 0;
        miss_count = 0;
        total_latency = 0;

        for (int i = 0; i < 24; i++) begin
            issue_demand(base_addr + i * stride);
            repeat(3) @(posedge clk);
        end

        repeat(MEM_LATENCY_CYCLES * 2) @(posedge clk);

        $display("  Requests: %0d, Hits: %0d, Misses: %0d", total_requests, hit_count, miss_count);
        $display("  Hit rate: %0.1f%%", 100.0 * hit_count / total_requests);
        $display("  Stride detected: %b", stride_detected);
    endtask

    // Test 3: Random access (should see no prefetch benefit)
    task test_random();
        $display("\n=== Test 3: Random Access ===");

        total_requests = 0;
        hit_count = 0;
        miss_count = 0;
        total_latency = 0;

        for (int i = 0; i < 20; i++) begin
            issue_demand($urandom() & 40'hFFFF_FFFF);
            repeat(MEM_LATENCY_CYCLES + 5) @(posedge clk);  // Wait for each response
        end

        $display("  Requests: %0d, Hits: %0d", total_requests, hit_count);
        $display("  Random access hit rate: %0.1f%% (expected ~0%%)",
                 100.0 * hit_count / total_requests);
    endtask

    // Test 4: Burst then random (stride detection reset)
    task test_pattern_change();
        $display("\n=== Test 4: Pattern Change ===");
        logic [ADDR_WIDTH-1:0] base_addr = 40'h20000;

        total_requests = 0;
        hit_count = 0;

        // Sequential burst
        for (int i = 0; i < 16; i++) begin
            issue_demand(base_addr + i * 64);
            repeat(2) @(posedge clk);
        end

        $display("  After sequential: Hits=%0d, Confidence=%0d", hit_count, prefetch_confidence);

        // Random access should reduce confidence
        for (int i = 0; i < 8; i++) begin
            issue_demand($urandom() & 40'hFFFF);
            repeat(MEM_LATENCY_CYCLES) @(posedge clk);
        end

        $display("  After random: Confidence=%0d", prefetch_confidence);
    endtask

    //--------------------------------------------------------------------------
    // Main Test
    //--------------------------------------------------------------------------
    initial begin
        $display("\n");
        $display("==============================================================");
        $display("  Prefetch Buffer Testbench");
        $display("  PREFETCH_DEPTH=%0d, MEM_LATENCY=%0d cycles",
                 PREFETCH_DEPTH, MEM_LATENCY_CYCLES);
        $display("==============================================================");

        reset_dut();

        test_sequential();
        reset_dut();

        test_strided();
        reset_dut();

        test_random();
        reset_dut();

        test_pattern_change();

        $display("\n");
        $display("==============================================================");
        $display("  All tests completed");
        $display("==============================================================");
        $display("\n");

        $finish;
    end

    // Timeout
    initial begin
        #(CLK_PERIOD_NS * 50000);
        $error("Global timeout!");
        $finish;
    end

endmodule
