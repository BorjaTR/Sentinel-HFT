//==============================================================================
// Prefetch Buffer with Stride Detection
//
// Generated by Sentinel-HFT FixPack Generator
// Template Version: 1.0.0
// Pattern: MEMORY_BANDWIDTH
//
// Parameters:
//   DATA_WIDTH = {{ params.DATA_WIDTH }}
//   ADDR_WIDTH = {{ params.ADDR_WIDTH }}
//   PREFETCH_DEPTH = {{ params.PREFETCH_DEPTH }}
//   STRIDE_HISTORY = {{ params.STRIDE_HISTORY }}
//   CONFIDENCE_THRESHOLD = {{ params.CONFIDENCE_THRESHOLD }}
//   MAX_OUTSTANDING = {{ params.MAX_OUTSTANDING }}
//   AXI_ID_WIDTH = {{ params.AXI_ID_WIDTH }}
//
// Expected Impact:
//   Latency reduction: ~{{ metadata.expected_latency_reduction_pct }}%
//   Throughput improvement: ~{{ metadata.expected_throughput_improvement_pct }}%
//
// CANDIDATE FIX - Review Required Before Use
//==============================================================================

module prefetch_buffer #(
    parameter int DATA_WIDTH = {{ params.DATA_WIDTH }},
    parameter int ADDR_WIDTH = {{ params.ADDR_WIDTH }},
    parameter int PREFETCH_DEPTH = {{ params.PREFETCH_DEPTH }},
    parameter int STRIDE_HISTORY = {{ params.STRIDE_HISTORY }},
    parameter int CONFIDENCE_THRESHOLD = {{ params.CONFIDENCE_THRESHOLD }},
    parameter int MAX_OUTSTANDING = {{ params.MAX_OUTSTANDING }},
    parameter int AXI_ID_WIDTH = {{ params.AXI_ID_WIDTH }}
) (
    input  logic                    clk,
    input  logic                    rst_n,

    // Demand interface (from core)
    input  logic [ADDR_WIDTH-1:0]   demand_addr,
    input  logic                    demand_valid,
    output logic                    demand_ready,
    output logic [DATA_WIDTH-1:0]   demand_data,
    output logic                    demand_data_valid,
    output logic                    demand_hit,  // Hit in prefetch buffer

    // AXI4 Read Address Channel (to memory)
    output logic [AXI_ID_WIDTH-1:0] axi_arid,
    output logic [ADDR_WIDTH-1:0]   axi_araddr,
    output logic [7:0]              axi_arlen,
    output logic [2:0]              axi_arsize,
    output logic [1:0]              axi_arburst,
    output logic                    axi_arvalid,
    input  logic                    axi_arready,

    // AXI4 Read Data Channel (from memory)
    input  logic [AXI_ID_WIDTH-1:0] axi_rid,
    input  logic [DATA_WIDTH-1:0]   axi_rdata,
    input  logic [1:0]              axi_rresp,
    input  logic                    axi_rlast,
    input  logic                    axi_rvalid,
    output logic                    axi_rready,

    // Status
    output logic [3:0]              prefetch_confidence,
    output logic [$clog2(PREFETCH_DEPTH):0] buffer_occupancy,
    output logic                    stride_detected
);

    //--------------------------------------------------------------------------
    // Local Parameters
    //--------------------------------------------------------------------------
    localparam int PTR_WIDTH = $clog2(PREFETCH_DEPTH);
    localparam int STRIDE_WIDTH = ADDR_WIDTH;  // Signed stride

    //--------------------------------------------------------------------------
    // Prefetch Buffer Storage
    //--------------------------------------------------------------------------
    typedef struct packed {
        logic [ADDR_WIDTH-1:0] addr;
        logic [DATA_WIDTH-1:0] data;
        logic                  valid;
        logic                  pending;  // Request sent, data not yet received
    } prefetch_entry_t;

    prefetch_entry_t buffer [PREFETCH_DEPTH];

    //--------------------------------------------------------------------------
    // Stride Detection State
    //--------------------------------------------------------------------------
    logic [ADDR_WIDTH-1:0] last_addrs [STRIDE_HISTORY];
    logic [STRIDE_HISTORY-1:0] addr_valid;
    logic signed [STRIDE_WIDTH-1:0] detected_stride;
    logic [3:0] confidence;
    logic [PTR_WIDTH-1:0] next_prefetch_ptr;

    //--------------------------------------------------------------------------
    // Outstanding Request Tracking
    //--------------------------------------------------------------------------
    logic [$clog2(MAX_OUTSTANDING):0] outstanding_count;
    logic [AXI_ID_WIDTH-1:0] next_id;

    //--------------------------------------------------------------------------
    // Demand Hit Detection
    //--------------------------------------------------------------------------
    logic                  hit_found;
    logic [PTR_WIDTH-1:0]  hit_index;
    logic [DATA_WIDTH-1:0] hit_data;

    always_comb begin
        hit_found = 1'b0;
        hit_index = '0;
        hit_data = '0;

        for (int i = 0; i < PREFETCH_DEPTH; i++) begin
            if (buffer[i].valid && !buffer[i].pending &&
                buffer[i].addr == demand_addr) begin
                hit_found = 1'b1;
                hit_index = i;
                hit_data = buffer[i].data;
                break;
            end
        end
    end

    assign demand_hit = hit_found && demand_valid;
    assign demand_data = hit_found ? hit_data : axi_rdata;
    assign demand_data_valid = demand_hit || (axi_rvalid && axi_rready && !buffer[axi_rid].pending);

    //--------------------------------------------------------------------------
    // Stride Detection Logic
    //--------------------------------------------------------------------------
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < STRIDE_HISTORY; i++) begin
                last_addrs[i] <= '0;
            end
            addr_valid <= '0;
            detected_stride <= '0;
            confidence <= '0;
        end else if (demand_valid && demand_ready) begin
            // Shift address history
            for (int i = STRIDE_HISTORY-1; i > 0; i--) begin
                last_addrs[i] <= last_addrs[i-1];
            end
            last_addrs[0] <= demand_addr;
            addr_valid <= {addr_valid[STRIDE_HISTORY-2:0], 1'b1};

            // Calculate stride when we have enough history
            if (addr_valid[1]) begin  // At least 2 addresses
                logic signed [STRIDE_WIDTH-1:0] new_stride;
                new_stride = demand_addr - last_addrs[0];

                if (new_stride == detected_stride && detected_stride != 0) begin
                    // Stride confirmed, increase confidence
                    if (confidence < 15) confidence <= confidence + 1;
                end else begin
                    // New or different stride
                    detected_stride <= new_stride;
                    confidence <= 4'd1;
                end
            end
        end
    end

    assign prefetch_confidence = confidence;
    assign stride_detected = (confidence >= CONFIDENCE_THRESHOLD);

    //--------------------------------------------------------------------------
    // Prefetch Address Generation
    //--------------------------------------------------------------------------
    logic [ADDR_WIDTH-1:0] prefetch_addr;
    logic                  should_prefetch;

    always_comb begin
        // Predict next addresses based on detected stride
        prefetch_addr = last_addrs[0] + detected_stride * (outstanding_count + 1);

        // Should we prefetch?
        should_prefetch = stride_detected &&
                         (outstanding_count < MAX_OUTSTANDING) &&
                         !buffer_full;
    end

    //--------------------------------------------------------------------------
    // Buffer Management
    //--------------------------------------------------------------------------
    logic buffer_full;
    logic [PTR_WIDTH-1:0] free_slot;
    logic has_free_slot;

    always_comb begin
        buffer_full = 1'b1;
        has_free_slot = 1'b0;
        free_slot = '0;
        buffer_occupancy = '0;

        for (int i = 0; i < PREFETCH_DEPTH; i++) begin
            if (buffer[i].valid || buffer[i].pending) begin
                buffer_occupancy = buffer_occupancy + 1;
            end
            if (!buffer[i].valid && !buffer[i].pending && !has_free_slot) begin
                buffer_full = 1'b0;
                has_free_slot = 1'b1;
                free_slot = i;
            end
        end
    end

    //--------------------------------------------------------------------------
    // Prefetch Request FSM
    //--------------------------------------------------------------------------
    typedef enum logic [1:0] {
        IDLE,
        ISSUE_PREFETCH,
        ISSUE_DEMAND,
        WAIT_RESPONSE
    } state_t;

    state_t state;
    logic [ADDR_WIDTH-1:0] pending_addr;
    logic                  is_demand_req;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            axi_arvalid <= 1'b0;
            outstanding_count <= '0;
            next_id <= '0;

            for (int i = 0; i < PREFETCH_DEPTH; i++) begin
                buffer[i].valid <= 1'b0;
                buffer[i].pending <= 1'b0;
            end
        end else begin
            case (state)
                IDLE: begin
                    // Priority: demand miss > prefetch
                    if (demand_valid && !hit_found) begin
                        // Demand miss - issue read
                        axi_araddr <= demand_addr;
                        axi_arid <= next_id;
                        axi_arvalid <= 1'b1;
                        is_demand_req <= 1'b1;
                        state <= ISSUE_DEMAND;
                    end else if (should_prefetch && has_free_slot) begin
                        // Issue prefetch
                        axi_araddr <= prefetch_addr;
                        axi_arid <= next_id;
                        axi_arvalid <= 1'b1;
                        buffer[free_slot].addr <= prefetch_addr;
                        buffer[free_slot].pending <= 1'b1;
                        is_demand_req <= 1'b0;
                        state <= ISSUE_PREFETCH;
                    end

                    // Invalidate hit entry after consumption
                    if (demand_hit) begin
                        buffer[hit_index].valid <= 1'b0;
                    end
                end

                ISSUE_PREFETCH, ISSUE_DEMAND: begin
                    if (axi_arready) begin
                        axi_arvalid <= 1'b0;
                        next_id <= next_id + 1;
                        outstanding_count <= outstanding_count + 1;
                        state <= IDLE;
                    end
                end

                default: state <= IDLE;
            endcase

            // Handle read responses
            if (axi_rvalid && axi_rready) begin
                outstanding_count <= outstanding_count - 1;

                // Find matching pending entry
                for (int i = 0; i < PREFETCH_DEPTH; i++) begin
                    if (buffer[i].pending && i == axi_rid[PTR_WIDTH-1:0]) begin
                        buffer[i].data <= axi_rdata;
                        buffer[i].valid <= 1'b1;
                        buffer[i].pending <= 1'b0;
                    end
                end
            end
        end
    end

    //--------------------------------------------------------------------------
    // AXI Interface Defaults
    //--------------------------------------------------------------------------
    assign axi_arlen = 8'd0;  // Single beat
    assign axi_arsize = $clog2(DATA_WIDTH/8);
    assign axi_arburst = 2'b01;  // INCR
    assign axi_rready = 1'b1;  // Always ready to accept data
    assign demand_ready = (state == IDLE) || hit_found;

    //--------------------------------------------------------------------------
    // Assertions
    //--------------------------------------------------------------------------
`ifdef SIMULATION
    // synthesis translate_off

    // No buffer overflow
    assert property (@(posedge clk) disable iff (!rst_n)
        buffer_occupancy <= PREFETCH_DEPTH
    ) else $error("Buffer overflow!");

    // Outstanding count consistency
    assert property (@(posedge clk) disable iff (!rst_n)
        outstanding_count <= MAX_OUTSTANDING
    ) else $error("Too many outstanding requests!");

    // synthesis translate_on
`endif

endmodule
